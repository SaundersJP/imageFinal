import ij.*;
import ij.plugin.filter.PlugInFilter;
import ij.process.*;
import ij.gui.*;
import java.awt.*;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.awt.event.*;
import java.util.*;
import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * This plugin implements the MouseListener and MouseMotionListener interfaces
 * and listens for mouse events generated by the current image.
 */
public class mouseEvent_ implements PlugInFilter, MouseListener, MouseMotionListener {
	private int width;
	private int height;
	private double sperm = 3.06;
	protected ImagePlus img;
	protected ImagePlus output;
	protected ImageCanvas canvas;
	protected ArrayList<PointPixel> curve;
	protected ArrayList<ArrayList<Integer>> adjacencyList;
	protected ArrayList<PathDist> path;
	protected ArrayList<ArrayList<int[]>> pathPixels;
	protected PathDist tempPath = null;
	static Vector images = new Vector();

	// Expects a stack of 2 images with the first being a skeleton and the second
	// the original image
	public int setup(String arg, ImagePlus img) {
		this.img = img;
		this.width = img.getWidth();
		this.height = img.getHeight();
		this.path = new ArrayList<PathDist>();
		IJ.register(mouseEvent_.class);

		byte[] originalPixels = (byte[]) img.getStack().getPixels(2);
		ImageProcessor original_ip = new ByteProcessor(width, height, originalPixels);
		output = new ImagePlus("Path", original_ip);
		ImageConverter output_conv = new ImageConverter(output);
		output_conv.convertToRGB();
		ImageProcessor output_ip = output.getProcessor();
		// output.show();

		ImageStack currStack = img.getImageStack();
		currStack.deleteSlice(2);
		img.setStack(currStack);
		this.img = img;

		createCurve(img.getProcessor());

		ImageConverter imgConv = new ImageConverter(img);
		imgConv.convertToRGB();
		ImageProcessor ip = img.getProcessor();
		ip.copyBits(output_ip, 0, 0, Blitter.COPY);

		int[] pixels = (int[]) ip.getPixels();

		for (PointPixel pp : curve) {
			pixels[pp.pixel[0] + pp.pixel[1] * width] = (((255 & 0xFF) << 8));
		}

		img.updateAndDraw();

		this.img = img;
		// smoothPoints2D(this.curve, this.adjacencyList);
		return DOES_RGB + DOES_STACKS;
	}

	public void run(ImageProcessor ip) {
		Integer id = new Integer(img.getID());
		if (images.contains(id)) {
			IJ.log("Already listening to this image");
			return;
		} else {
			ImageWindow win = img.getWindow();
			canvas = win.getCanvas();
			canvas.addMouseListener(this);
			canvas.addMouseMotionListener(this);
			// int tool = Toolbar.getInstance().addTool("Test Tool");
			// Toolbar.getInstance().setTool(tool);
			images.addElement(id);
		}
	}

	public void mousePressed(MouseEvent e) {
		int x = e.getX();
		int y = e.getY();
		int offscreenX = canvas.offScreenX(x);
		int offscreenY = canvas.offScreenY(y);
		ImageProcessor ip = img.getProcessor();

		// rightClick
		if ((e.getModifiers() & Event.META_MASK) != 0) {
			IJ.log("right click today!!");
		}
		// shiftLeftClick
		else if ((e.getModifiers() & Event.SHIFT_MASK) != 0) {
			IJ.log("Mouse pressed: " + offscreenX + "," + offscreenY + modifiers(e.getModifiers()));
			finalizeLastPath();
			img.updateAndDraw();
			// output.updateAndDraw();
		}
		// ctrlLeftClick
		else if ((e.getModifiers() & Event.CTRL_MASK) != 0) {
			Double length = computePathDist(path, curve, adjacencyList);
			IJ.log(Double.toString(length / sperm));
		}
		// leftClick
		else {
			IJ.log("Left click");
			PointPixel closestPoint = getClosestPoint(this.curve, offscreenX, offscreenY);
			Point2D closestPoint2D = closestPoint.p;
			int closestX = closestPoint.pixel[0];
			int closestY = closestPoint.pixel[1];
			IJ.log(Integer.toString(closestX));
			IJ.log(Integer.toString(closestY));

			if (this.path.size() == 0) {
				int indexInCurve = this.curve.indexOf(closestPoint);
				PathDist currPath = new PathDist(closestPoint, 0, indexInCurve);
				this.path.add(currPath);
				IJ.log("set initial path");
			} else {
				IJ.log("undo path");
				undoLastTempPath();
				IJ.log("new path");
				tempPath(closestPoint);
			}

			img.updateAndDraw();
			// output.updateAndDraw();
		}
	}

	public void mouseReleased(MouseEvent e) {
	}

	public void mouseDragged(MouseEvent e) {
	}

	public static String modifiers(int flags) {
		String s = " [ ";
		if (flags == 0)
			return "";
		if ((flags & Event.SHIFT_MASK) != 0)
			s += "Shift ";
		if ((flags & Event.CTRL_MASK) != 0)
			s += "Control ";
		if ((flags & Event.META_MASK) != 0)
			s += "Meta (right button) ";
		if ((flags & Event.ALT_MASK) != 0)
			s += "Alt ";
		s += "]";
		if (s.equals(" [ ]"))
			s = " [no modifiers]";
		return s;
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseClicked(MouseEvent e) {
	}

	public void mouseEntered(MouseEvent e) {
	}

	public void mouseMoved(MouseEvent e) {
	}

	public void createCurve(ImageProcessor ip) {
		int width = ip.getWidth();
		int height = ip.getHeight();

		byte[] pixels = (byte[]) ip.getPixels();
		int[] pixelToPoint2DMap = new int[pixels.length];
		Arrays.fill(pixelToPoint2DMap, -1);
		ArrayList<PointPixel> points = new ArrayList<PointPixel>();
		ArrayList<ArrayList<Integer>> adjList;

		int iter = 0;
		for (int x = 0; x < width; ++x) {
			for (int y = 0; y < height; ++y) {
				if (pixels[x + y * width] != 0) {
					int[] pixel = new int[2];
					pixel[0] = x;
					pixel[1] = y;
					pixelToPoint2DMap[x + y * width] = iter++;
					points.add(new PointPixel(new Point2D.Double(x, y), pixel));
				}
			}
		}

		int[][] conn = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };
		adjList = new ArrayList<ArrayList<Integer>>(points.size());
		for (int i = 0; i < points.size(); ++i) {
			adjList.add(new ArrayList<Integer>());
		}
		for (int x = 0; x < width; ++x) {
			for (int y = 0; y < height; ++y) {
				for (int i = 0; i < conn.length; ++i) {
					int pointNum = pixelToPoint2DMap[x + y * width];
					if (pointNum < 0) {
						continue;
					}
					int xnew = x + conn[i][0];
					int ynew = y + conn[i][1];

					if (xnew >= 0 && xnew < width && ynew >= 0 && ynew < height) {
						if (pixelToPoint2DMap[xnew + ynew * width] >= 0) {
							int adjPoint2DNum = pixelToPoint2DMap[xnew + ynew * width];
							adjList.get(pointNum).add(adjPoint2DNum);
						}
					}
				}
			}
		}

		this.curve = points;
		this.adjacencyList = adjList;
	}

	public void smoothPoints2D(ArrayList<PointPixel> points, ArrayList<ArrayList<Integer>> adjList) {
		double lambda = .5;
		double k = .001;

		int iterations = 100;
		for (int j = 0; j < iterations; ++j) {
			for (int i = 0; i < points.size(); ++i) {
				Point2D point = points.get(i).p;
				ArrayList<Integer> adjPoint2Ds = adjList.get(i);
				if (adjPoint2Ds.size() != 2) {
					continue;
				}
				Point2D p1 = points.get(adjPoint2Ds.get(0)).p;
				Point2D p2 = points.get(adjPoint2Ds.get(1)).p;
				Point2D midPoint2D = new Point2D.Double((p1.getX() + p2.getX()) / 2, (p1.getY() + p2.getY()) / 2);
				double l;
				if (j % 2 == 0) {
					l = lambda;
				} else {
					l = 1 / (k - 1 / lambda);
				}

				double newx = (1 - l) * point.getX() + l * midPoint2D.getX();
				double newy = (1 - l) * point.getY() + l * midPoint2D.getY();
				point.setLocation(newx, newy);
			}
		}
	}

	public PointPixel getClosestPoint(ArrayList<PointPixel> points, int x, int y) {
		PointPixel closestPoint = null;
		Double closestDistance = Double.POSITIVE_INFINITY;
		for (PointPixel point : points) {
			Point2D currPoint2D = point.p;
			Double diffX = currPoint2D.getX() - x;
			Double diffY = currPoint2D.getY() - y;
			Double currDistance = Math.sqrt(diffX * diffX + diffY * diffY);
			if (currDistance < closestDistance) {
				closestDistance = currDistance;
				closestPoint = point;
			}
		}
		return closestPoint;
	}

	public PathDist getShortestPath(PointPixel nextPoint) {
		PathDist lastPoint = path.get(path.size() - 1);

		if (lastPoint.p == nextPoint) {
			return lastPoint;
		}
		int ind = curve.indexOf(lastPoint.p);
		PriorityQueue<PathDist> pathEnds = new PriorityQueue<PathDist>(new SortByDist());
		pathEnds.add(new PathDist(lastPoint.p, 0, ind));

		HashSet<PointPixel> addedPoints = new HashSet<PointPixel>();
		addedPoints.add(lastPoint.p);

		while (true) {
			PathDist pd = pathEnds.poll();
			if (pd == null) {
				System.out.println("F");
			}
			int index = pd.index;
			for (int pointNum : adjacencyList.get(index)) {
				PathDist newPath = pd.clone();
				PointPixel newPP = curve.get(pointNum);
				if (addedPoints.contains(newPP)) {
					continue;
				}
				newPath.addPoint(newPP, pointNum);
				addedPoints.add(newPP);
				if (newPP.equals(nextPoint)) {
					return newPath;
				}
				if (newPP == nextPoint) {
					return newPath;
				}
				pathEnds.add(newPath);
			}
		}
	}

	// public PathDist computeNextPath(Point2D nextPoint) {
	// if (curve.size() == 0)
	// return null;
	// PointPixel closestPoint = curve.get(0);
	// double minDist = closestPoint.p.distance(nextPoint);
	// for (PointPixel pp : curve) {
	// double dist = pp.p.distance(nextPoint);
	// if (dist < minDist) {
	// closestPoint = pp;
	// }
	// }
	//
	// return getShortestPath(closestPoint);
	// }

	public void tempPath(PointPixel nextPoint) {
		ImageProcessor ip = img.getProcessor();
		int[] image = (int[]) ip.getPixels();

		// ImageProcessor out_ip = output.getProcessor();
		// int[] outputImage = (int[]) out_ip.getPixels();

		PathDist nextPath = getShortestPath(nextPoint);
		tempPath = nextPath;

		int r = (255 & 0xFF) << 16;
		int g = (0 & 0xFF) << 8;
		int b = (0 & 0xFF);

		for (PointPixel pp : nextPath.path) {
			int[] pixel = pp.pixel;
			// SetColor
			image[pixel[0] + width * pixel[1]] = (r + b + g);
			// outputImage[pixel[0] + width * pixel[1]] = (r + b + g);
		}
	}

	public void undoLastTempPath() {
		ImageProcessor ip = img.getProcessor();
		int[] image = (int[]) ip.getPixels();

		// ImageProcessor out_ip = output.getProcessor();
		// int[] outputImage = (int[]) out_ip.getPixels();

		int r = (0 & 0xFF) << 16;
		int g = (0 & 0xFF) << 8;
		int b = (255 & 0xFF);

		if (tempPath != null) {
			for (PointPixel pp : tempPath.path) {
				int[] pixel = pp.pixel;
				image[pixel[0] + width * pixel[1]] = ((255 & 0xFF) << 8);
				// outputImage[pixel[0] + width * pixel[1]] = 0;
			}
			for(PathDist lastPath : path) {
				for (PointPixel pp : lastPath.path) {
					int[] pixel = pp.pixel;
					image[pixel[0] + width * pixel[1]] = (r + g + b);
					// outputImage[pixel[0] + width * pixel[1]] = (r + g + b);
				}
			}
		}
	}

	public void finalizeLastPath() {
		ImageProcessor ip = img.getProcessor();
		int[] image = (int[]) ip.getPixels();
		// ImageProcessor out_ip = output.getProcessor();
		// int[] outputImage = (int[]) out_ip.getPixels();

		int r = (0 & 0xFF) << 16;
		int g = (0 & 0xFF) << 8;
		int b = (255 & 0xFF);

		if (tempPath != null) {
			for (PointPixel pp : tempPath.path) {
				int[] pixel = pp.pixel;
				image[pixel[0] + width * pixel[1]] = (r + g + b);
				// outputImage[pixel[0] + width * pixel[1]] = (r + g + b);
			}
			this.path.add(tempPath);
			tempPath = null;
		}
	}

	public double computePathDist(ArrayList<PathDist> paths, ArrayList<PointPixel> points,
			ArrayList<ArrayList<Integer>> adjList) {
		double length = 0;

		// smoothPoints2D(points, adjList);

		for (PathDist path : paths) {
			ArrayList<PointPixel> plist = path.path;
			for (int i = 0; i < plist.size() - 1; ++i) {
				// Point2D p1 = path.path.get(i).p;
				// Point2D p2 = path.path.get(i + 1).p;
				// if(p1.distance(p2) < 0) {
				// System.out.println("FUCK");
				// }
				// length += p1.distance(p2);
			}
			length += path.dist;
			System.out.println(length);
		}
		return length;
	}

	class PointPixel {
		Point2D p;
		int[] pixel;

		PointPixel(Point2D point, int[] pix) {
			p = point;
			pixel = pix;
		}

		PointPixel(PointPixel pp) {
			p = (Point2D) pp.p.clone();
			pixel = pp.pixel.clone();
		}

		public PointPixel clone() {
			return new PointPixel(this);
		}
	}

	class PathDist {
		PointPixel p;
		double dist;
		int index;
		ArrayList<PointPixel> path;

		PathDist(PointPixel point, double d, int i) {
			p = point;
			dist = d;
			index = i;
			path = new ArrayList<PointPixel>();
			path.add(point);
		}

		PathDist(PathDist pd) {
			p = pd.p.clone();
			dist = pd.dist;
			index = pd.index;
			path = new ArrayList<PointPixel>(pd.path);
		}

		public PathDist clone() {
			return new PathDist(this);
		}

		public void addPoint(PointPixel pp, int ind) {
			dist += p.p.distance(pp.p);
			p = pp;
			index = ind;
			path.add(pp);
		}
	}

	class SortByDist implements Comparator<PathDist> {

		@Override
		public int compare(PathDist a, PathDist b) {
			if (a.dist < b.dist)
				return -1;
			if (a.dist > b.dist)
				return 1;
			return 0;
		}
	}

}
